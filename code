# read.csv() 

ethnicity <- read.csv("set file path/KS201EW_oa11.csv")
rooms <- read.csv("set file path/KS403EW_oa11.csv")
qualifications <-read.csv("set file path/KS501EW_oa11.csv")
employment <-read.csv("set file path/KS601EW_oa11.csv")

# to view the top 1000 cases of a data frame
View(employment)

# view column names of a dataframe
names(employment)

# selecting specific columns only
# note this action overwrites the labels you made for the original data, 
# so if you make a mistake you will need to reload the data into R
ethnicity <- ethnicity[, c(1, 21)]
rooms <- rooms[, c(1, 13)]
employment <- employment[, c(1, 20)]
qualifications <- qualifications[, c(1, 20)]

# to change an individual column name
names(employment)[2] <- "Unemployed"

# to change both column names

names(ethnicity)<- c("OA", "White_British")
names(rooms)<- c("OA", "Low_Occupancy")
names(employment)<- c("OA", "Unemployed")
names(qualifications)<- c("OA", "Qualification")

#1 Merge Ethnicity and Rooms to create a new object called "merged_data_1"
merged_data_1 <- merge(ethnicity, rooms, by="OA")

#2 Merge the "merged_data_1" object with Employment to create a new merged data object
merged_data_2 <- merge(merged_data_1, employment, by="OA")

#3 Merge the "merged_data_2" object with Qualifications to create a new data object
census_data <- merge(merged_data_2, qualifications, by="OA")

#4 Remove the "merged_data" objects as we won't need them anymore
rm(merged_data_1, merged_data_2)

# Writes the data to a csv named "practical_data_Tower Hamlets" in your file directory
write.csv(census_data,"set file path/Tower Hamlets//practical_data_Tower_Hamlets.csv", row.names=F)

# Load the data. You may need to alter the file directory
  
Census.Data <-read.csv("set file path/Tower Hamlets/practical_data_Tower_Hamlets.csv")
  
# load the spatial libraries
library("sp")
library("rgdal")
library("rgeos")

# Load the output area shapefiles
Output.Areas <- readOGR("set file path/Tower Hamlets", "Tower_Hamlets_oa11")

OA.Census <- merge(Output.Areas, Census.Data, by.x="OA11CD", by.y="OA")

library("tmap")

tm_shape(OA.Census) + tm_fill("Qualification", palette = "Reds", style = "quantile", title = "% with a Qualification") + tm_borders(alpha=.4)  

#running a spatial autocorrelation 
library(spdep)

#finding neighbours 
# Calculate neighbours
neighbours <- poly2nb(OA.Census)
neighbours

#plot link between neighbours to visualise their distribution across space 
plot(OA.Census, border = 'lightgrey')
plot(neighbours, coordinates(OA.Census), add=TRUE, col='red')

# Calculate the Rook's case neighbours
neighbours2 <- poly2nb(OA.Census, queen = FALSE)
neighbours2

# compares different types of neighbours
plot(OA.Census, border = 'lightgrey')
plot(neighbours, coordinates(OA.Census), add=TRUE, col='blue')
plot(neighbours2, coordinates(OA.Census), add=TRUE, col='red')

#running a global spatial autocorrelation 

# Convert the neighbour data to a listw object
listw <- nb2listw(neighbours2)
listw

# global spatial autocorrelation
moran.test(OA.Census$Qualification, listw)

# running a local spatial autocorrelation 
# creates a moran plot
moran <- moran.plot(OA.Census$Qualification, listw = nb2listw(neighbours2, style = "C"),asp=T)

# creates a local moran output
local <- localmoran(x = OA.Census$Qualification, listw = nb2listw(neighbours2, style = "W"))

# binds results to our polygon shapefile
moran.map <- OA.Census

moran.map@data<- cbind(OA.Census@data, local)

# maps the results
tm_shape(moran.map) + tm_fill(col = "Ii", style = "quantile", title = "local moran statistic") 

moran <- moran.plot(OA.Census$Qualification, listw = nb2listw(neighbours2, style = "C"),asp=T)

### to create LISA cluster map ### 
quadrant <- vector(mode="numeric",length=nrow(local))

# centers the variable of interest around its mean
m.qualification <- OA.Census$Qualification - mean(OA.Census$Qualification)     

# centers the local Moran's around the mean
m.local <- local[,1] - mean(local[,1])    

# significance threshold
signif <- 0.1 

# builds a data quadrant
quadrant[m.qualification <0 & m.local<0] <- 1      
quadrant[m.qualification <0 & m.local>0] <- 2
quadrant[m.qualification >0 & m.local<0] <- 3
quadrant[m.qualification >0 & m.local>0] <- 4 
quadrant[local[,5]>signif] <- 0 

# plot in r
brks <- c(0,1,2,3,4)
colors <- c("white","blue",rgb(0,0,1,alpha=0.4),rgb(1,0,0,alpha=0.4),"red")
plot(OA.Census,border="lightgray",col=colors[findInterval(quadrant,brks,all.inside=FALSE)])
box()

legend("bottomleft",legend=c("insignificant","low-low","low-high","high-low","high-high"),
       fill=colors,bty="n")

#getis-ord 

# creates centroid and joins neighbours within 0 and x units
nb <- dnearneigh(coordinates(OA.Census),0,800)
# creates listw
nb_lw <- nb2listw(nb, style = 'B')

# plot the data and neighbours
plot(OA.Census, border = 'lightgrey')
plot(nb, coordinates(OA.Census), add=TRUE, col = 'red')

# compute Getis-Ord Gi statistic
local_g <- localG(OA.Census$Qualification, nb_lw)

local_g_sp<- OA.Census

local_g_sp@data <- cbind(OA.Census@data, as.matrix(local_g))
names(local_g_sp)[6] <- "gstat"

# map the results
tm_shape(local_g_sp) + tm_fill("gstat", palette = "RdBu", style = "pretty") + tm_borders(alpha=.4)
